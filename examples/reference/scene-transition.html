<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three Low Poly - Scene Transition</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "three";
      import GUI from "lil-gui";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { SceneTransition } from "../../src/index.js";

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 5, 15);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Create scene transition instance
      const sceneTransition = new SceneTransition(renderer);

      // ========================================
      // Scene 1: Forest (Green with trees)
      // ========================================
      const forestScene = new THREE.Scene();
      forestScene.background = new THREE.Color(0x87ceeb);
      forestScene.fog = new THREE.Fog(0x87ceeb, 10, 50);

      const forestAmbient = new THREE.AmbientLight(0xffffff, 0.6);
      forestScene.add(forestAmbient);

      const forestSun = new THREE.DirectionalLight(0xffffee, 1.0);
      forestSun.position.set(10, 15, 5);
      forestSun.castShadow = true;
      forestScene.add(forestSun);

      // Ground
      const forestGround = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 50),
        new THREE.MeshStandardMaterial({ color: 0x5a8a5a })
      );
      forestGround.rotation.x = -Math.PI / 2;
      forestGround.receiveShadow = true;
      forestScene.add(forestGround);

      // Trees
      for (let i = 0; i < 20; i++) {
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.3, 0.4, 3, 8),
          new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        trunk.position.set((Math.random() - 0.5) * 40, 1.5, (Math.random() - 0.5) * 40);
        trunk.castShadow = true;
        forestScene.add(trunk);

        const leaves = new THREE.Mesh(
          new THREE.ConeGeometry(2, 4, 8),
          new THREE.MeshStandardMaterial({ color: 0x228B22 })
        );
        leaves.position.copy(trunk.position);
        leaves.position.y += 4;
        leaves.castShadow = true;
        forestScene.add(leaves);
      }

      // ========================================
      // Scene 2: Desert (Orange/Yellow sand)
      // ========================================
      const desertScene = new THREE.Scene();
      desertScene.background = new THREE.Color(0xffd700);
      desertScene.fog = new THREE.Fog(0xffd700, 10, 50);

      const desertAmbient = new THREE.AmbientLight(0xffffff, 0.8);
      desertScene.add(desertAmbient);

      const desertSun = new THREE.DirectionalLight(0xffffaa, 1.2);
      desertSun.position.set(10, 15, 5);
      desertSun.castShadow = true;
      desertScene.add(desertSun);

      // Sand
      const desertGround = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 50, 20, 20),
        new THREE.MeshStandardMaterial({ color: 0xdaa520, roughness: 0.9 })
      );
      desertGround.rotation.x = -Math.PI / 2;
      desertGround.receiveShadow = true;
      // Add some dunes
      const positions = desertGround.geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getZ(i);
        positions.setY(i, Math.sin(x * 0.2) * Math.cos(z * 0.2) * 2);
      }
      desertGround.geometry.computeVertexNormals();
      desertScene.add(desertGround);

      // Cacti
      for (let i = 0; i < 15; i++) {
        const cactus = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, 3, 6),
          new THREE.MeshStandardMaterial({ color: 0x228B22 })
        );
        cactus.position.set((Math.random() - 0.5) * 40, 1.5, (Math.random() - 0.5) * 40);
        cactus.castShadow = true;
        desertScene.add(cactus);
      }

      // ========================================
      // Scene 3: Ocean (Blue with waves)
      // ========================================
      const oceanScene = new THREE.Scene();
      oceanScene.background = new THREE.Color(0x1e90ff);

      const oceanAmbient = new THREE.AmbientLight(0xffffff, 0.5);
      oceanScene.add(oceanAmbient);

      const oceanSun = new THREE.DirectionalLight(0xffffff, 1.0);
      oceanSun.position.set(5, 10, 5);
      oceanScene.add(oceanSun);

      // Water
      const waterGeometry = new THREE.PlaneGeometry(50, 50, 50, 50);
      const waterMaterial = new THREE.MeshStandardMaterial({
        color: 0x006994,
        roughness: 0.3,
        metalness: 0.5,
      });
      const water = new THREE.Mesh(waterGeometry, waterMaterial);
      water.rotation.x = -Math.PI / 2;
      oceanScene.add(water);

      // Animate water
      const waterPositions = waterGeometry.attributes.position;
      const waterUpdate = () => {
        const time = Date.now() * 0.001;
        for (let i = 0; i < waterPositions.count; i++) {
          const x = waterPositions.getX(i);
          const z = waterPositions.getZ(i);
          const y = Math.sin(x * 0.2 + time) * Math.cos(z * 0.2 + time) * 0.5;
          waterPositions.setY(i, y);
        }
        waterGeometry.attributes.position.needsUpdate = true;
        waterGeometry.computeVertexNormals();
      };

      // Boats
      for (let i = 0; i < 5; i++) {
        const boat = new THREE.Mesh(
          new THREE.BoxGeometry(2, 1, 4),
          new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        boat.position.set((Math.random() - 0.5) * 30, 0.5, (Math.random() - 0.5) * 30);
        oceanScene.add(boat);
      }

      // ========================================
      // Scene 4: Night City (Dark with lights)
      // ========================================
      const cityScene = new THREE.Scene();
      cityScene.background = new THREE.Color(0x0a0a1e);
      cityScene.fog = new THREE.Fog(0x0a0a1e, 10, 50);

      const cityAmbient = new THREE.AmbientLight(0x666699, 0.3);
      cityScene.add(cityAmbient);

      // Ground
      const cityGround = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 50),
        new THREE.MeshStandardMaterial({ color: 0x333333 })
      );
      cityGround.rotation.x = -Math.PI / 2;
      cityGround.receiveShadow = true;
      cityScene.add(cityGround);

      // Buildings
      for (let i = 0; i < 20; i++) {
        const height = 3 + Math.random() * 8;
        const building = new THREE.Mesh(
          new THREE.BoxGeometry(2, height, 2),
          new THREE.MeshStandardMaterial({ color: 0x444444 })
        );
        building.position.set((Math.random() - 0.5) * 40, height / 2, (Math.random() - 0.5) * 40);
        building.castShadow = true;
        cityScene.add(building);

        // Window lights
        if (Math.random() > 0.3) {
          const light = new THREE.PointLight(0xffff00, 2, 10);
          light.position.copy(building.position);
          light.position.y += height / 2;
          cityScene.add(light);
        }
      }

      const scenes = {
        Forest: forestScene,
        Desert: desertScene,
        Ocean: oceanScene,
        City: cityScene,
      };

      const sceneNames = Object.keys(scenes);

      // Initialize with forest scene
      sceneTransition.setCurrentScene(forestScene);

      // Animation loop
      function animate() {
        // Update water animation
        waterUpdate();

        // Update transition
        sceneTransition.update();

        // Render with scene transition - if no transition, render current scene
        if (!sceneTransition.getIsTransitioning()) {
          const currentScene = sceneTransition.getCurrentScene();
          if (currentScene) {
            renderer.render(currentScene, camera);
          }
        } else {
          sceneTransition.render();
        }

        controls.update();
        requestAnimationFrame(animate);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        sceneTransition.setSize(window.innerWidth, window.innerHeight);
      });

      // GUI Controls
      const gui = new GUI();

      const transitionSettings = {
        currentScene: "Forest",
        targetScene: "Desert",
        transitionType: "fade",
        duration: 1500,
        easing: "CUBIC_EASE_IN_OUT",
        fadeColor: "#000000",
        progress: 0,
        startTransition: () => {
          const fromScene = scenes[transitionSettings.currentScene];
          const toScene = scenes[transitionSettings.targetScene];

          const options = {
            duration: transitionSettings.duration,
            easing: transitionSettings.easing,
            onUpdate: (progress) => {
              progressController.setValue(progress);
            },
            onComplete: () => {
              transitionSettings.currentScene = transitionSettings.targetScene;
              currentSceneController.setValue(transitionSettings.currentScene);

              // Auto-advance target to next scene for easy sequential transitions
              const currentIndex = sceneNames.indexOf(transitionSettings.currentScene);
              const nextIndex = (currentIndex + 1) % sceneNames.length;
              transitionSettings.targetScene = sceneNames[nextIndex];
              targetSceneController.setValue(transitionSettings.targetScene);
            },
          };

          if (transitionSettings.transitionType === "fade") {
            sceneTransition.fade(fromScene, toScene, camera, {
              ...options,
              color: transitionSettings.fadeColor,
            });
          } else if (transitionSettings.transitionType === "crossfade") {
            sceneTransition.crossfade(fromScene, toScene, camera, options);
          } else if (transitionSettings.transitionType === "blur") {
            sceneTransition.blur(fromScene, toScene, camera, options);
          }
        },
      };

      const sceneFolder = gui.addFolder("Scene Selection");

      const currentSceneController = sceneFolder
        .add(transitionSettings, "currentScene", Object.keys(scenes))
        .name("Current Scene")
        .listen();

      const targetSceneController = sceneFolder
        .add(transitionSettings, "targetScene", Object.keys(scenes))
        .name("Target Scene");

      sceneFolder.open();

      const transitionFolder = gui.addFolder("Transition Settings");

      transitionFolder
        .add(transitionSettings, "transitionType", ["fade", "crossfade", "blur"])
        .name("Transition Type");

      transitionFolder
        .add(transitionSettings, "duration", 500, 3000, 100)
        .name("Duration (ms)");

      transitionFolder
        .add(transitionSettings, "easing", [
          "LINEAR",
          "QUADRATIC_EASE_IN",
          "QUADRATIC_EASE_OUT",
          "QUADRATIC_EASE_IN_OUT",
          "CUBIC_EASE_IN",
          "CUBIC_EASE_OUT",
          "CUBIC_EASE_IN_OUT",
          "QUARTIC_EASE_IN_OUT",
        ])
        .name("Easing");

      transitionFolder
        .addColor(transitionSettings, "fadeColor")
        .name("Fade Color")
        .onChange((value) => {
          transitionSettings.fadeColor = value;
        });

      const progressController = transitionFolder
        .add(transitionSettings, "progress", 0, 1)
        .name("Progress")
        .listen();
      progressController.disable();

      transitionFolder.open();

      const actionFolder = gui.addFolder("Actions");
      actionFolder.add(transitionSettings, "startTransition").name("▶ Start Transition");
      actionFolder.open();
    </script>
  </body>
</html>
